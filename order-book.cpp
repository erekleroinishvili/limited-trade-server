#include <iostream>
#include <iomanip>
#include <string>
#include <regex>
#include <optional>
#include <assert.h>
#include <queue>
#include "all-includes.h"

using namespace std;

class OrderBook {
private:
    priority_queue<Order, vector<Order>, greater<Order>> buyLedger;
    priority_queue<Order, vector<Order>, greater<Order>> sellLedger;
    vector<Order> listLedger(priority_queue<Order, vector<Order>, greater<Order>> ledger) const {
        vector<Order> ledgerList;
        while (!ledger.empty()) {
            ledgerList.push_back(ledger.top());
            ledger.pop();
        }
        return ledgerList;
    }

public:
    /**
     * @brief Adds the order to the Order Book and executes order aggressively against other matching orders
     * @return List of trades generated by the order execution
     */
    vector<Trade> insertAggressive(Order & aggressiveOrder) {
        auto & aggressiveLedger = aggressiveOrder.type == BUY ? this->buyLedger : this->sellLedger;
        auto & passiveLedger = aggressiveOrder.type == SELL ? this->buyLedger : this->sellLedger;

        TradeList tradeList;

        while (!aggressiveOrder.fulfilled() && !passiveLedger.empty() && aggressiveOrder.canTradeAt(passiveLedger.top().price)) {
            auto passiveOrder = passiveLedger.top();
            passiveLedger.pop();

            const unsigned int tradeVolume = min(aggressiveOrder.volume, passiveOrder.volume);
            if (aggressiveOrder.type == BUY) {
                tradeList.addTrade({aggressiveOrder.id, passiveOrder.id, passiveOrder.price, tradeVolume});
            } else {
                tradeList.addTrade({passiveOrder.id, aggressiveOrder.id, passiveOrder.price, tradeVolume});
            }
            aggressiveOrder.trade(tradeVolume);
            passiveOrder.trade(tradeVolume);

            if (!passiveOrder.fulfilled()) passiveLedger.push(passiveOrder);
        }

        aggressiveOrder.becomePassive();
        if (!aggressiveOrder.fulfilled()) aggressiveLedger.push(aggressiveOrder);
        return tradeList.getTrades();
    }
    vector<Order> getBuyLedger() const {
        return listLedger(buyLedger);
    }
    vector<Order> getSellLedger() const {
        return listLedger(sellLedger);
    }

    friend std::ostream & operator<<(std::ostream & out, const OrderBook & book);
};
